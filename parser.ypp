%{
/*
 * parser.ypp
 * Copyright (C) 2016 Nemanja Mićović <nmicovic@outlook.com>
 *
 * Distributed under terms of the MIT license.
 */

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>

#include "Expression.hpp"
#include "Statement.hpp"
#include "LLVMCodegen.hpp"
#include "Types.hpp"
#include "TypeChecker.hpp"
#include "ProgramOptions.hpp"

#define YYDEBUG 1

int yylex();
void yyerror(const std::string &err_msg) {
    std::cerr << err_msg << std::endl;
    exit(EXIT_FAILURE);
}

%}

/* Types */
%token int_ty_tok double_ty_tok string_ty_tok void_ty_tok
/* Methods */
%token stdout_printf_tok
/* Keywords */
%token return_tok for_tok while_tok if_tok else_tok

%union {
    // Constants
    int int_val;
    double double_val;
    std::string* str_val;

    // Statements
    vlang::StmtAST* stmt;
    std::vector<vlang::StmtAST*>* vec_stmt;

    // Expressions
    vlang::ExprAST* expr;

    // Functions
    vlang::PrototypeAST* proto;
    vlang::FunctionAST* fun;

    // Other
    std::vector<std::pair<vlang::VLANG_TYPE, std::string> >* vec_pair_type_name;
    std::pair<vlang::VLANG_TYPE, std::string>* pair_type_name;

    std::pair<std::string, vlang::ExprAST*>* pair_str_expr;
    std::vector<std::pair<std::string, vlang::ExprAST*>>* vec_pair_str_expr;
    vlang::VLANG_TYPE vtype;
}

%nonassoc else_tok
%left '='
%left '>' '<'
%left '+' '-' '%'
%left '*' '/'

%token <int_val> int_val_tok
%token <double_val> double_val_tok
%token <str_val> str_val_tok id_tok

%type <expr> Expr

%type <proto> FunDeclaration
%type <fun> FunDefinition

%type <vtype> VlangType

%type <pair_type_name> Arg
%type <vec_pair_type_name> ArgList

%type <pair_str_expr> Assignment
%type <vec_pair_str_expr> Assignments

%type <vec_stmt> Instructions Program TheProgram
%type <stmt> Instruction Stmt

%%
TheProgram: Program {
    if (vlang::util::ProgramOptions::get().emit_source()) {
        for (auto &stmt : *$1)
            std::cout << stmt->dump() << std::endl;
    }
    delete $1;
}

/* Program is a series of statements */
Program: Program Stmt {
    $$ = $1;
    $$->push_back($2);
}
| Stmt {
    $$ = new std::vector<vlang::StmtAST*>();
    $$->push_back($1);
}
| {
    $$ = new std::vector<vlang::StmtAST*>();
}
;

/* A statement is something like a function declaration,
class creation, enum creation, function definition...*/
Stmt: FunDeclaration ';' {
    $$ = $1;
}
| FunDefinition {
    $$ = $1;
}
;

/* A function declaration */
FunDeclaration: VlangType id_tok '(' ArgList ')' {
    $$ = new vlang::PrototypeAST(*$2, $1, *$4);
    delete $2;
    delete $4;
}
;

/* A function definition */
FunDefinition: FunDeclaration '{' Instructions '}' {
    $$ = new vlang::FunctionAST(*$1, new vlang::BlockStmtAST(*$3));
    delete $1;
    delete $3;
}
;

/* A chain of instructions */
Instructions: Instructions Instruction {
    $$ = $1;
    $$->push_back($2);
}
| Instruction {
    $$ = new std::vector<vlang::StmtAST*>();
    $$->push_back($1);
}
;

/* Instruction is what we write inside functions like function calls,
return, expression evaluation etc. */
Instruction: return_tok Expr ';' {
    $$ = new vlang::ReturnStmtAST($2);
}
| Expr ';' {
    $$ = new vlang::ExpressionStmtAST($1);
}
| id_tok '=' Expr ';' {
    $$ = new vlang::AssignmentStmtAST(vlang::VLANG_TYPE::NO_VAR_DECL, *$1, $3);
    delete $1;
}
/* Changed with Assignments (more abstract)
| VlangType id_tok '=' Expr ';' {
    $$ = new vlang::AssignmentStmtAST($1, *$2, $4);
    delete $2;
}
*/
| VlangType Assignments ';' {
    $$ = new vlang::AssignmentListStmtAST($1, *$2);
    delete $2;
}
/*| Assignments ';' {*/
    /*$$ = new vlang::AssignmentListStmtAST(vlang::VLANG_TYPE::NO_VAR_DECL, *$1);*/
    /*delete $1;*/
/*}*/
| if_tok '(' Expr ')' Instruction {
    $$ = new vlang::IfStmtAST($3, $5);
}
| if_tok '(' Expr ')' Instruction else_tok Instruction {
    $$ = new vlang::IfElseStmtAST($3, $5, $7);
}
| while_tok '(' Expr ')' Instruction {
    $$ = new vlang::WhileStmtAST($3, $5);
}
| '{' Instructions '}' {
    $$ = new vlang::BlockStmtAST(*$2);
    delete $2;
}
| ';' {
    $$ = new vlang::EmptyStmtAST();
}
;

Expr: '(' Expr ')' {
    $$ = $2;
}
| Expr '+' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("+", $1, $3);
}
| Expr '-' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("-", $1, $3);
}
| Expr '*' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("*", $1, $3);
}
| Expr '/' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("/", $1, $3);
}
| Expr '%' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("%", $1, $3);
}
| Expr '<' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST("<", $1, $3);
}
| Expr '>' Expr {
    vlang::TypeChecker::checkTypesWithDiagnostics($1, $3);
    $$ = new vlang::BinaryExprAST(">", $1, $3);
}
| int_val_tok {
    $$ = new vlang::ConstIntExprAST($1);
}
| double_val_tok {
    $$ = new vlang::ConstDoubleExprAST($1);
}
| str_val_tok {
    $$ = new vlang::StringExprAST(*$1);
    delete $1;
}
| id_tok {
    $$ = new vlang::VariableExprAST(*$1);
    delete $1;
}
;

/* Making assignment list */
Assignments: Assignments ',' Assignment {
    $$ = $1;
    $$->push_back(*$3);
    delete $3;
}
| Assignment {
    $$ = new std::vector<std::pair<std::string, vlang::ExprAST*>>();
    $$->push_back(*$1);
    delete $1;
};

Assignment: id_tok '=' Expr {
    $$ = new std::pair<std::string, vlang::ExprAST*>(*$1, $3);
    delete $1;
}
| id_tok {
    $$ = new std::pair<std::string, vlang::ExprAST*>(*$1, nullptr);
    delete $1;
}

/* What kind of types are supported */
VlangType: int_ty_tok {
    $$ = vlang::VLANG_TYPE::INT32;
}
| double_ty_tok {
    $$ = vlang::VLANG_TYPE::DOUBLE;
}
| string_ty_tok {
    $$ = vlang::VLANG_TYPE::STRING;
}
| void_ty_tok {
    $$ = vlang::VLANG_TYPE::VOID;
}
;

/* A chain of function arguments */
ArgList: ArgList ',' Arg {
    $$ = $1;
    $$->push_back(*$3);
    delete $3;
}
| Arg {
    $$ = new std::vector<std::pair<vlang::VLANG_TYPE, std::string> >();
    $$->push_back(*$1);
    delete $1;
}
| {
    $$ = new std::vector<std::pair<vlang::VLANG_TYPE, std::string> >();
}
;

/* A function argument */
Arg: VlangType id_tok {
    $$ = new std::pair<vlang::VLANG_TYPE, std::string>($1, *$2);
    delete $2;
}

%%
extern FILE* yyin;
int main(int argc, char** argv) {
    /*yydebug = 1;*/
    vlang::util::ProgramOptions::get().init(argc, argv);

    // For now, we only support one file
    if (vlang::util::ProgramOptions::get().contains_input_files()) {
        std::string input = vlang::util::ProgramOptions::get().first_input_file();
        std::cout << "Input file: " << input << std::endl;
        yyin = fopen(input.c_str(), "r");
        if (yyin == NULL) {
            std::cerr << "Failed reading input '" << input << "'" << std::endl;
            return 1;
        }
    }
    std::cout << "Output: " << vlang::util::ProgramOptions::get().output_path() << std::endl;

    yyparse();

    fclose(yyin);
    return 0;
}

